<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>IBONIRIUM ¬∑ SPACE FOREST ¬∑ ETERNAL SYNC EXP-03</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            cursor: crosshair;
            color: #c7ffd9;
        }

        canvas {
            position: fixed;
            inset: 0;
            touch-action: none;
        }

        #sensors {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            height: 180px;
            pointer-events: none;
            z-index: 5;
        }

        #info {
            position: fixed;
            bottom: 15px;
            left: 15px;
            color: #9affc2;
            font-size: 13px;
            /* –¢—Ä–æ—Ö–∏ –±—ñ–ª—å—à–∏–π —à—Ä–∏—Ñ—Ç */
            line-height: 1.5;
            opacity: 0.9;
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 10;
        }

        #panel {
            position: fixed;
            bottom: 15px;
            right: 15px;
            max-width: 360px;
            color: #c7ffd9;
            font-size: 12px;
            /* –¢—Ä–æ—Ö–∏ –±—ñ–ª—å—à–∏–π —à—Ä–∏—Ñ—Ç */
            line-height: 1.5;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding: 15px 20px;
            border-radius: 4px;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.9);
            pointer-events: none;
            z-index: 10;
            border-right: 3px solid #0ff;
        }

        #cycle {
            position: fixed;
            top: 15px;
            right: 15px;
            color: #ffd700;
            font-size: 15px;
            /* –¢—Ä–æ—Ö–∏ –±—ñ–ª—å—à–∏–π —à—Ä–∏—Ñ—Ç */
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding: 10px 15px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 10;
            border-left: 3px solid #ffd700;
        }

        #treeInfo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #0ff;
            padding: 25px;
            border-radius: 8px;
            color: #0ff;
            max-width: 90%;
            width: 380px;
            display: none;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.3);
            z-index: 100;
            pointer-events: auto;
        }

        #treeInfo h3 {
            margin-bottom: 15px;
            color: #0ff;
            font-size: 16px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            padding-bottom: 8px;
        }

        #treeInfo .close {
            position: absolute;
            top: 10px;
            right: 15px;
            cursor: pointer;
            font-size: 20px;
            color: #f44;
        }

        #eternalTimer b {
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
        }

        @media (max-width: 600px) {
            #panel {
                max-width: 200px;
                font-size: 9px;
            }

            #info {
                font-size: 9px;
                bottom: 140px;
                /* Lift up to avoid overlap with sensors/panel on very small screens */
            }

            #sensors {
                height: 140px;
            }
        }
    </style>
</head>

<body>
    <canvas id="stars"></canvas>
    <canvas id="aurora"></canvas>
    <canvas id="forestBack"></canvas>
    <canvas id="forestMid"></canvas>
    <canvas id="forestFront"></canvas>
    <canvas id="sensors"></canvas>

    <div id="info">
        <b>IBONIRIUM ¬∑ SPACE FOREST ¬∑ ETERNAL</b><br>
        Status: <span id="syncStatus">Syncing...</span><br>
        Cycle: <span id="cycleNum">1</span> | Day: <span id="dayNum">‚Äì</span> / 13<br>
        <br>
        <b>‚òÄ SOLAR DATA (NOAA)</b><br>
        SSN: <span id="ssn">‚Äì</span> | Flare: <span id="flare">None</span><br>
        Proton: <span id="proton">‚Äì</span> | Wind: <span id="wind">‚Äì</span><br>
        <br>
        <b>üåç GEOMAGNETIC</b><br>
        Kp Index: <span id="kp">‚Äì</span> | Bz: <span id="bz">‚Äì</span><br>
        Electron: <span id="electron">‚Äì</span><br>
        <br>
        <b>‚ö° FOREST STATE</b><br>
        Radiation: <span id="rad">Low</span> | Storm: <span id="storm">Calm</span><br>
        Trees: <span id="treeCount">‚Äì</span> | Gen: <span id="avgGen">‚Äì</span>
    </div>

    <div id="panel">
        <b>–°–¢–ê–ù –ï–ö–°–ü–ï–†–ò–ú–ï–ù–¢–£: –í–Ü–ß–ù–ò–ô –õ–Ü–°</b><br>
        <div id="eternalTimer">...</div>
        <br>
        <b>–í–ø–ª–∏–≤–∏:</b><br>
        ‚Ä¢ SSN + Solar Wind ‚Üí —à–≤–∏–¥–∫—ñ—Å—Ç—å —Ä–æ—Å—Ç—É<br>
        ‚Ä¢ Proton Flux ‚Üí —Ä–∞–¥—ñ–∞—Ü—ñ–π–Ω–µ –æ—Ç—Ä—É—î–Ω–Ω—è<br>
        ‚Ä¢ X/M Flares ‚Üí —Ä–∞–ø—Ç–æ–≤—ñ —à–æ–∫–∏ (–ø—É–ª—å—Å–∞—Ü—ñ—è)<br>
        ‚Ä¢ Kp Index ‚Üí –≥–µ–æ–º–∞–≥–Ω—ñ—Ç–Ω—ñ —Ö–≤–∏–ª—ñ + –∞–≤—Ä–æ—Ä–∞<br>
        ‚Ä¢ Bz South ‚Üí –ø–æ—Å–∏–ª–µ–Ω–Ω—è –±—É—Ä—ñ (–¥–µ—Ñ–æ—Ä–º–∞—Ü—ñ—è)<br>
        ‚Ä¢ Electron Flux ‚Üí –µ–Ω–µ—Ä–≥–µ—Ç–∏—á–Ω—ñ —ñ—Å–∫—Ä–∏<br>
        <br>
        <b>–¶–∏–∫–ª:</b> –ö–æ–∂–Ω—ñ 13 –¥–Ω—ñ–≤ –¥–µ—Ä–µ–≤–∞ –º—É—Ç—É—é—Ç—å.
    </div>

    <div id="cycle">üîÑ CYCLE <span id="cycleDisplay">...</span></div>

    <div id="treeInfo">
        <span class="close">‚úï</span>
        <h3>üå≤ Deep Genetic Analysis</h3>
        <div id="treeDetails"></div>
    </div>

    <script>
        const canvases = ['stars', 'aurora', 'forestBack', 'forestMid', 'forestFront', 'sensors'];
        const ctxs = {};
        canvases.forEach(id => ctxs[id] = document.getElementById(id).getContext('2d'));

        function resize() {
            canvases.forEach(id => {
                const c = document.getElementById(id);
                c.width = window.innerWidth;
                c.height = id === 'sensors' ? 180 : window.innerHeight;
            });
        }
        window.addEventListener('resize', resize); resize();

        // --- TIME ENGINE (Deterministic Timeline) ---
        const START_DATE = new Date('2026-01-01T00:00:00');
        const MS_PER_CYCLE = 13 * 24 * 60 * 60 * 1000;
        const MS_PER_DAY = 24 * 60 * 60 * 1000;

        let timeline = { totalMs: 0, cycles: 0, msInCycle: 0, progress: 0, day: 0 };

        function updateTimeline() {
            const now = new Date();
            timeline.totalMs = now - START_DATE;
            timeline.cycles = Math.floor(timeline.totalMs / MS_PER_CYCLE);
            timeline.msInCycle = timeline.totalMs % MS_PER_CYCLE;
            timeline.progress = timeline.msInCycle / MS_PER_CYCLE;
            timeline.day = Math.floor(timeline.msInCycle / MS_PER_DAY);

            document.getElementById('cycleNum').textContent = timeline.cycles + 1;
            document.getElementById('dayNum').textContent = timeline.day;
            document.getElementById('cycleDisplay').textContent = (timeline.cycles + 1) + " | DAY " + timeline.day + "/13";
            document.getElementById('syncStatus').textContent = "Timeline Active";
            document.getElementById('avgGen').textContent = timeline.cycles + 1;

            // LIVE TIMER FROM 01.01.2026
            const diff = timeline.totalMs;
            const d = Math.floor(diff / (1000 * 60 * 60 * 24));
            const h = Math.floor((diff / (1000 * 60 * 60)) % 24);
            const m = Math.floor((diff / (1000 * 60)) % 60);
            const s = Math.floor((diff / 1000) % 60);
            document.getElementById('eternalTimer').innerHTML = `<b>–í—ñ–¥–ª—ñ–∫:</b> ${d}–¥ ${h}–≥ ${m}—Ö–≤ ${s}—Å`;
        }

        // --- NOAA & REALTIME DATA ---
        let spaceWeather = {
            ssn: 0, proton: 0, kp: 0, wind: 400, bz: 0, electron: 0,
            radLevel: 0, stormLevel: 0, flare: 'None', aurora: false,
            isSimulated: true
        };

        async function fetchJSON(url) {
            const resp = await fetch(url);
            if (!resp.ok) throw new Error('CORS or Network Error');
            return resp.json();
        }

        async function updateSpaceWeather() {
            try {
                const [rSSN, rKp, rWind, rFlare, rProt, rElec] = await Promise.allSettled([
                    fetchJSON('https://services.swpc.noaa.gov/json/solar-cycle/predicted-solar-cycle.json'),
                    fetchJSON('https://services.swpc.noaa.gov/json/planetary_k_index_1m.json'),
                    fetchJSON('https://services.swpc.noaa.gov/json/rtsw/rtsw_wind_1m.json'),
                    fetchJSON('https://services.swpc.noaa.gov/json/goes/primary/xray-flares-7-day.json'),
                    fetchJSON('https://services.swpc.noaa.gov/json/goes/primary/integral-protons-plot-6-hour.json'),
                    fetchJSON('https://services.swpc.noaa.gov/json/goes/primary/integral-electrons-plot-6-hour.json')
                ]);

                if (rSSN.status === 'fulfilled') spaceWeather.ssn = rSSN.value[rSSN.value.length - 1]?.predicted_ssn || 50;
                if (rKp.status === 'fulfilled') spaceWeather.kp = rKp.value[rKp.value.length - 1]?.kp_index || 1;
                if (rWind.status === 'fulfilled') {
                    const latest = rWind.value[rWind.value.length - 1];
                    spaceWeather.wind = parseFloat(latest?.wind_speed) || 400;
                    spaceWeather.bz = parseFloat(latest?.bz) || 0;
                }
                if (rFlare.status === 'fulfilled') spaceWeather.flare = rFlare.value[rFlare.value.length - 1]?.current_class || 'None';
                if (rProt.status === 'fulfilled') spaceWeather.proton = parseFloat(rProt.value[rProt.value.length - 1]?.flux) || 1;
                if (rElec.status === 'fulfilled') spaceWeather.electron = parseFloat(rElec.value[rElec.value.length - 1]?.flux) || 100;

                spaceWeather.isSimulated = false;
            } catch (e) {
                spaceWeather.isSimulated = true;
            }

            if (spaceWeather.isSimulated) {
                const t = Date.now() * 0.001;
                spaceWeather.ssn = 40 + Math.sin(t * 0.05) * 30;
                spaceWeather.kp = 1 + Math.abs(Math.sin(t * 0.1)) * 5;
                spaceWeather.wind = 350 + Math.abs(Math.sin(t * 0.08)) * 300;
                spaceWeather.proton = 1 + Math.abs(Math.sin(t * 0.12)) * 10;
                spaceWeather.electron = 100 + Math.abs(Math.sin(t * 0.04)) * 800;
                spaceWeather.bz = Math.sin(t * 0.15) * 15;
            }

            let flareBoost = spaceWeather.flare.startsWith('X') ? 0.9 : spaceWeather.flare.startsWith('M') ? 0.4 : 0.1;
            spaceWeather.radLevel = Math.min(1, (Math.log10(spaceWeather.proton + 1) / 5) + flareBoost);
            spaceWeather.stormLevel = Math.min(1, (spaceWeather.kp / 9) + (spaceWeather.bz < 0 ? Math.abs(spaceWeather.bz) / 20 : 0) * 0.3);
            spaceWeather.aurora = spaceWeather.kp >= 5 || (spaceWeather.kp >= 3 && spaceWeather.bz < -5);

            document.getElementById('ssn').textContent = spaceWeather.ssn.toFixed(1);
            document.getElementById('proton').textContent = spaceWeather.proton.toFixed(2);
            document.getElementById('kp').textContent = spaceWeather.kp.toFixed(1);
            document.getElementById('wind').textContent = spaceWeather.wind.toFixed(0);
            document.getElementById('bz').textContent = spaceWeather.bz.toFixed(1);
            document.getElementById('electron').textContent = spaceWeather.electron.toFixed(0);
            document.getElementById('flare').textContent = spaceWeather.flare + (spaceWeather.isSimulated ? " (!)" : "");

            document.getElementById('rad').textContent = spaceWeather.radLevel < 0.3 ? 'Low' : spaceWeather.radLevel < 0.7 ? 'High' : 'Severe';
            document.getElementById('rad').style.color = spaceWeather.radLevel > 0.5 ? '#f44' : '#9affc2';
            document.getElementById('storm').textContent = spaceWeather.stormLevel < 0.3 ? 'Calm' : spaceWeather.stormLevel < 0.7 ? 'Active' : 'Storm';
            document.getElementById('storm').style.color = spaceWeather.stormLevel > 0.5 ? '#f0f' : '#9affc2';
        }
        setInterval(updateSpaceWeather, 600000); updateSpaceWeather();

        // --- VISUAL ELEMENTS ---
        let mouseX = 0.5, mouseY = 0.5;
        window.addEventListener('mousemove', e => {
            mouseX = e.clientX / window.innerWidth;
            mouseY = e.clientY / window.innerHeight;
        });
        window.addEventListener('touchmove', e => {
            mouseX = e.touches[0].clientX / window.innerWidth;
            mouseY = e.touches[0].clientY / window.innerHeight;
        });

        // Stars
        const stars = Array.from({ length: 400 }, () => ({
            x: Math.random(), y: Math.random(), z: Math.random() * 0.8 + 0.2,
            twinkle: Math.random() * 10, speed: 0.3 + Math.random() * 0.5,
            layer: Math.random() < 0.3 ? 'back' : Math.random() < 0.6 ? 'mid' : 'front'
        }));

        function drawStars() {
            const ctx = ctxs.stars; ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            stars.forEach(s => {
                const pf = s.layer === 'back' ? 0.02 : s.layer === 'mid' ? 0.05 : 0.1;
                let px = ((s.x + (mouseX - 0.5) * pf) * window.innerWidth) % window.innerWidth;
                let py = ((s.y + (mouseY - 0.5) * pf * 0.5) * window.innerHeight) % window.innerHeight;
                if (px < 0) px += window.innerWidth;
                if (py < 0) py += window.innerHeight;
                ctx.globalAlpha = 0.3 + s.z * 0.5 + Math.sin(Date.now() * 0.002 + s.twinkle) * 0.2;
                ctx.fillStyle = "#fff";
                ctx.beginPath(); ctx.arc(px, py, s.z * 1.5, 0, Math.PI * 2); ctx.fill();
            });
        }

        // Aurora
        const auroraWaves = Array.from({ length: 8 }, (_, i) => ({ phase: Math.random() * 10, speed: 0.001 + i * 0.0003, amp: 40 + i * 15 }));
        function drawAurora() {
            const ctx = ctxs.aurora; ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            if (!spaceWeather.aurora && spaceWeather.stormLevel < 0.2) return;
            const intensity = Math.max(spaceWeather.stormLevel, spaceWeather.aurora ? 0.7 : 0);
            auroraWaves.forEach((w, i) => {
                w.phase += w.speed;
                const grad = ctx.createLinearGradient(0, 0, 0, window.innerHeight * 0.6);
                const hue = 140 + Math.sin(Date.now() * 0.0002 + i) * 60;
                grad.addColorStop(0, `hsla(${hue}, 80%, 50%, ${intensity * 0.2})`);
                grad.addColorStop(0.5, `hsla(${hue + 40}, 90%, 40%, ${intensity * 0.3})`);
                grad.addColorStop(1, "transparent");
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.moveTo(0, window.innerHeight * 0.3);
                for (let x = 0; x <= window.innerWidth; x += 25) {
                    const y = window.innerHeight * 0.3 + Math.sin(x * 0.005 + w.phase) * w.amp * intensity;
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(window.innerWidth, 0); ctx.lineTo(0, 0); ctx.fill();
            });
        }

        // Geo Waves
        const geoWaves = [];
        function spawnGeoWave() {
            if (spaceWeather.stormLevel > 0.4 && Math.random() < 0.02) {
                geoWaves.push({ x: Math.random() * window.innerWidth, y: window.innerHeight * 0.7, r: 0, a: 0.8, h: 180 + Math.random() * 60 });
            }
        }
        function drawGeoWaves(ctx) {
            geoWaves.forEach((w, i) => {
                w.r += 2 + spaceWeather.stormLevel * 3; w.a -= 0.005;
                if (w.a <= 0) { geoWaves.splice(i, 1); return; }
                ctx.strokeStyle = `hsla(${w.h}, 100%, 60%, ${w.a})`;
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(w.x, w.y, w.r, 0, Math.PI * 2); ctx.stroke();
            });
        }

        // Particles
        const particles = [];
        function spawnParticle() {
            if (Math.random() < spaceWeather.radLevel * 0.4) {
                particles.push({
                    x: Math.random() * window.innerWidth, y: -20, vy: 3 + Math.random() * 5,
                    type: Math.random() < 0.5 ? 'rad' : 'storm',
                    layer: Math.random() < 0.5 ? 'mid' : 'front'
                });
            }
        }
        function drawParticles(ctx, layer) {
            particles.forEach((p, i) => {
                if (p.layer !== layer) return;
                p.y += p.vy;
                if (p.y > window.innerHeight) { particles.splice(i, 1); return; }
                ctx.fillStyle = p.type === 'rad' ? (spaceWeather.radLevel > 0.6 ? '#f0f' : '#c8f') : '#0ff';
                ctx.globalAlpha = 0.6;
                ctx.fillRect(p.x, p.y, 2, 12);
            });
        }

        // --- COSMIC TREE (Integrated Engine) ---
        class DeterministicTree {
            constructor(id, layer) {
                this.id = id;
                this.x = (Math.abs(Math.sin(id * 666.666)) * 0.9) + 0.05;
                this.layer = layer;
                this.baseSeed = id * 777.777;
            }

            getParams(cycle) {
                const seed = this.baseSeed + cycle;
                const rnd = (n) => Math.abs(Math.sin(seed * n));
                return {
                    type: Math.floor(rnd(1.1) * 4),
                    maxAge: 4.5 + rnd(1.2) * 3,
                    branchAngle: 0.45 + rnd(1.3) * 0.5,
                    hueOff: rnd(1.4) * 60
                };
            }

            draw(ctx) {
                const cycle = timeline.cycles;
                const p = this.getParams(cycle);
                const deterministicMemory = cycle * 1.5;
                const age = (timeline.progress * p.maxAge) + deterministicMemory;

                const scale = this.layer === 'back' ? 0.6 : this.layer === 'mid' ? 0.85 : 1.1;
                const opacity = this.layer === 'back' ? 0.4 : this.layer === 'mid' ? 0.7 : 1.0;
                const pf = this.layer === 'back' ? 0.03 : this.layer === 'mid' ? 0.06 : 0.12;

                let x = (this.x + (mouseX - 0.5) * pf) * ctx.canvas.width;
                let y = (ctx.canvas.height * 0.8) + (mouseY - 0.5) * pf * 40;

                const rad = spaceWeather.radLevel;
                const storm = spaceWeather.stormLevel;
                const solarBoost = (spaceWeather.ssn / 200) + (spaceWeather.wind / 1000);

                let len = (40 + cycle * 10) * scale * (1 + solarBoost * 0.2);
                let angle = -Math.PI / 2;

                let hue = 130 + p.hueOff;
                if (rad > 0.5) hue += 150 * rad;
                if (storm > 0.5) hue -= 40 * storm;

                ctx.strokeStyle = `hsla(${hue}, ${70 + storm * 30}%, ${50 + rad * 20}%, ${opacity})`;
                ctx.globalAlpha = (0.7 + Math.sin(Date.now() * 0.002 + this.id) * 0.1) * opacity;

                const steps = Math.min(30, Math.floor(age * 1.8));
                for (let i = 0; i < steps; i++) {
                    const nx = x + Math.cos(angle) * len;
                    const ny = y + Math.sin(angle) * len;
                    ctx.lineWidth = len * 0.12 * (1 - rad * 0.2);
                    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(nx, ny); ctx.stroke();

                    if (p.type === 0) angle += Math.sin(i * 1.5 + this.baseSeed + storm * 5) * p.branchAngle;
                    else if (p.type === 1) angle += (Math.sin(i * 2 + Date.now() * 0.001) * 0.4) + (Math.abs(Math.sin(this.id)) * 0.2);
                    else if (p.type === 2) angle += p.branchAngle * (i % 2 ? 1 : -1) * (1 + storm);
                    else angle += Math.cos(i * 0.5 + Date.now() * 0.001) * 0.6;

                    x = nx; y = ny; len *= 0.68 * (1 - rad * 0.05);
                }

                const crown = (10 + cycle * 4) * scale * (1 + storm * 0.4);
                ctx.fillStyle = `hsla(${hue + 40}, 100%, 70%, ${opacity})`;

                if (spaceWeather.flare.startsWith('X') || spaceWeather.flare.startsWith('M')) {
                    ctx.shadowBlur = 20 * (spaceWeather.flare.startsWith('X') ? 2 : 1);
                    ctx.shadowColor = "white";
                    ctx.beginPath(); ctx.arc(x, y, crown * 1.5, 0, Math.PI * 2); ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    ctx.beginPath(); ctx.arc(x, y, crown, 0, Math.PI * 2); ctx.fill();
                }

                if (spaceWeather.electron > 1500 && Math.random() < 0.05) {
                    ctx.fillStyle = "white";
                    ctx.beginPath(); ctx.arc(x + (Math.random() - 0.5) * 40, y + (Math.random() - 0.5) * 40, 2, 0, Math.PI * 2); ctx.fill();
                }

                this.screenX = x; this.screenY = y; this.screenR = crown * 2.5;
                this.lastData = { age, gen: cycle + 1, type: p.type, rad: rad, st: storm };
            }
        }

        const forest = [];
        for (let i = 0; i < 85; i++) {
            const layer = i < 30 ? 'back' : i < 60 ? 'mid' : 'front';
            forest.push(new DeterministicTree(i, layer));
        }

        // --- HANDLERS ---
        function handleInteraction(e) {
            const r = forestFrontC.getBoundingClientRect();
            const cx = (e.clientX || (e.touches && e.touches[0].clientX)) - r.left;
            const cy = (e.clientY || (e.touches && e.touches[0].clientY)) - r.top;
            let target = null, minDist = 60;
            forest.forEach(t => {
                const d = Math.sqrt((t.screenX - cx) ** 2 + (t.screenY - cy) ** 2);
                if (d < t.screenR && d < minDist) { target = t; minDist = d; }
            });
            if (target) {
                document.getElementById('treeDetails').innerHTML = `
                    <b>Generation:</b> ${target.lastData.gen}<br>
                    <b>Sync Age:</b> ${target.lastData.age.toFixed(2)}<br>
                    <b>Morphology:</b> ${['Neural', 'Crystal', 'Binary', 'Spiral'][target.lastData.type]}<br>
                    <b>Rad Pressure:</b> ${(target.lastData.rad * 100).toFixed(1)}%<br>
                    <b>Storm Charge:</b> ${(target.lastData.st * 100).toFixed(1)}%<br>
                    <b>Timeline:</b> ${timeline.day}d / Cycle ${timeline.cycles + 1}
                `;
                document.getElementById('treeInfo').style.display = 'block';
            }
        }

        document.getElementById('forestFront').addEventListener('click', handleInteraction);

        document.querySelector('#treeInfo .close').onclick = (e) => {
            e.stopPropagation();
            document.getElementById('treeInfo').style.display = 'none';
        };

        // --- HUD SENSORS ---
        function drawSensors() {
            const sctx = ctxs.sensors; sctx.clearRect(0, 0, window.innerWidth, 180);
            const by = 140;
            sctx.fillStyle = "rgba(255,215,0,0.1)"; sctx.fillRect(40, by, window.innerWidth - 80, 2);
            sctx.fillStyle = "#ffd700"; sctx.fillRect(40, by, (window.innerWidth - 80) * timeline.progress, 3);
            sctx.font = "9px monospace";
            sctx.fillStyle = "#ffd700";
            sctx.fillText("01.01.2026 >> SYNC PROGRESS", 40, by - 8);

            const drawGauge = (x, val, label, color) => {
                sctx.strokeStyle = "rgba(100,100,100,0.3)"; sctx.lineWidth = 2;
                sctx.beginPath(); sctx.arc(x, by - 60, 22, 0, Math.PI * 2); sctx.stroke();
                sctx.strokeStyle = color;
                sctx.beginPath(); sctx.arc(x, by - 60, 22, -Math.PI / 2, -Math.PI / 2 + val * Math.PI * 2); sctx.stroke();
                sctx.fillStyle = color; sctx.fillText(label, x - 12, by - 22);
            };
            const w = window.innerWidth;
            drawGauge(w * 0.2, Math.min(1, spaceWeather.ssn / 250), "SSN", "#ff0");
            drawGauge(w * 0.4, spaceWeather.radLevel, "RAD", "#f0f");
            drawGauge(w * 0.6, spaceWeather.stormLevel, "STORM", "#0ff");
            drawGauge(w * 0.8, (timeline.day / 13), "DAY", "#ffd");
        }

        // --- MAIN LOOP ---
        function loop() {
            updateTimeline();
            drawStars();
            drawAurora();
            drawSensors();
            ctxs.forestBack.clearRect(0, 0, window.innerWidth, window.innerHeight);
            ctxs.forestMid.clearRect(0, 0, window.innerWidth, window.innerHeight);
            ctxs.forestFront.clearRect(0, 0, window.innerWidth, window.innerHeight);
            forest.forEach(t => {
                if (t.layer === 'back') t.draw(ctxs.forestBack);
                else if (t.layer === 'mid') t.draw(ctxs.forestMid);
                else t.draw(ctxs.forestFront);
            });
            spawnGeoWave(); drawGeoWaves(ctxs.forestMid);
            spawnParticle(); drawParticles(ctxs.forestMid, 'mid'); drawParticles(ctxs.forestFront, 'front');
            requestAnimationFrame(loop);
        }
        document.getElementById('treeCount').textContent = forest.length;
        loop();
    </script>
</body>

</html>
